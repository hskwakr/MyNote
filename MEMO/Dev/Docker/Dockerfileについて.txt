
2021-02-12 22:10:37
Dockerfile リファレンス — Docker-docs-ja 19.03 ドキュメント https://docs.docker.jp/engine/reference/builder.html

```
 ビルド処理の開始時にまず行われるのは、コンテキスト全体を（再帰的に）デーモンに送信することです。 普通はコンテキストとして空のディレクトリを用意して、そこに Dockerfile を置きます。 そのディレクトリへは、Dockerfile の構築に必要となるファイルのみを置くようにします。
```
Dokcer用のフォルダを用意したほうがいいっぽいです。

docker - How to name Dockerfiles - Stack Overflow https://stackoverflow.com/questions/26077543/how-to-name-dockerfiles

今回はDBをDockerで用意するから
db/Dockerfile
みたいな感じでしょうか

2021-02-12 22:12:08
利用方法
```
ビルドコンテキスト内のファイルを利用する場合、Dockerfile では命令を記述する際にファイル参照を指定します。 たとえば COPY 命令の対象として参照します。 ビルド時の処理性能を上げるために、コンテキストディレクトリ内に .dockerignore ファイルを追加し、不要なファイルやディレクトリは除外するようにします。 
```

```
Docker デーモンは Dockerfile 内の命令を 1 つずつ実行し、必要な場合にはビルドイメージ内にその処理結果を確定します。 最後にビルドイメージの ID を出力します。 Docker デーモンは、送信されたコンテキスト内容を自動的にクリアします。

各命令は個別に実行されます。 それによって新たなイメージがビルドされます。 したがって、たとえば RUN cd /tmp を実行したとしても、次の命令には何の効果も与えません。
```

2021-02-12 22:21:04
記述書式

```
# Comment
INSTRUCTION arguments

命令（instruction）は大文字小文字を区別しません。 ただし慣習として大文字とします。 そうすることで引数（arguments）との区別をつけやすくします。
```

```
Docker は Dockerfile 内の命令を記述順に実行します。 Dockerfile は必ず FROM 命令で 始めなければなりません。 FROM 命令は、ビルドするイメージに対しての ベースイメージ を指定するものです。 FROM よりも先に記述できる命令として ARG があります。 これは FROM において用いられる引数を宣言するものです。
```

```
行頭が # で始まる行はコメントとして扱われます。 ただし例外として パーサ・ディレクティブ があります。 行途中の # は単なる引数として扱われます。 以下のような行記述が可能です。

# Comment
RUN echo 'we are running some # of cool things'
```

2021-02-12 23:53:53
環境変数の置換

```
Dockerfile の ENV 構文 により宣言される環境変数は、特定の命令において変数として解釈されます。 エスケープについても構文内にリテラルを含めることから、変数と同様の扱いと考えられます。

Dockerfile における環境変数の記述書式は、$variable_name あるいは ${variable_name} のいずれかが可能です。 両者は同等のものですが、ブレースを用いた記述は ${foo}_bar といった記述のように、変数名にホワイトスペースを含めないようにするために利用されます。
```

2021-02-13 21:47:22
.dockerignoreファイル
```
Docker の CLI によってコンテキストが Docker デーモンに送信される前には、コンテキストのルートディレクトリの .dockerignore というファイルが参照されます。 このファイルが存在したら、CLI はそこに記述されたパターンにマッチするようなファイルやディレクトリを除外した上で、コンテキストを扱います。 必要もないのに、巨大なファイルや取り扱い注意のファイルを不用意に送信してしまうことが避けられ、ADD や COPY を使ってイメージに間違って送信してしまうことを防ぐことができます。
```

```
除外したいファイルを指定するのではなく、含めたいファイルを指定したい場合があります。 これを実現するには、冒頭のマッチングパターンとして * を指定します。 そしてこれに続けて、例外となるパターンを ! を使って指定します。
```

2021-02-13 22:05:37
RUN
```
    RUN <command> （シェル形式、コマンドはシェル内で実行される、シェルとはデフォルトで Linux なら /bin/sh -c、Windows なら cmd /S /C）
    
    RUN ["executable", "param1", "param2"] （exec 形式）
```

2021-02-13 22:07:41
CMD
```
     

Dockerfile では CMD 命令を 1 つしか記述できません。 仮に複数の CMD を記述しても、最後の CMD 命令しか処理されません。

CMD 命令の主目的は、コンテナの実行時のデフォルト処理を設定することです。 この処理設定においては、実行モジュールを含める場合と、実行モジュールを省略する場合があります。 省略する場合は ENTRYPOINT 命令を合わせて指定する必要があります。
```

2021-02-13 22:09:34
LABEL
```

LABEL 命令はイメージに対してメタデータを追加します。 LABEL ではキーバリューペアによる記述を行います。 値に空白などを含める場合は、クォートとバックスラッシュを用います。 これはコマンドライン処理において行うことと同じです。 以下に簡単な例を示します。


イメージには複数のラベルを含めることができます。 複数のラベルを指定する場合、可能であれば LABEL 命令の記述を 1 行とすることをお勧めします。 LABEL 命令 1 つからは新しいレイヤが生成されますが、多数のラベルを利用すると、非効率なイメージがビルドされてしまいます。 以下の例は、ただ 1 つのイメージ・レイヤを作るものです。

LABEL multi.label1="value1" multi.label2="value2" other="value3"
```

2021-02-13 22:10:50
EXPOSE
```

EXPOSE 命令はコンテナの実行時に、所定ネットワーク上のどのポートをリッスンするかを指定します。 EXPOSE はコンテナーのポートをホストが利用できるようにするものではありません。 利用できるようにするためには -p フラグを使ってポートの公開範囲を指定するか、 -P フラグによって expose したポートをすべて公開する必要があります。 1 つのポート番号を expose して、これを外部に向けては別の番号により公開することも可能です。

ホストシステム上にてポート転送を行う場合は、-P フラグの利用 を参照してください。 Docker のネットワークにおいては、ネットワーク内でポートを expose しなくてもネットワークを生成できる機能がサポートされています。 詳しくは ネットワーク機能の概要 を参照してください。
```

2021-02-14 20:53:06
VOLUME
```
VOLUME 命令は指定された名前を使ってマウントポイントを生成します。 そして自ホストまたは他のコンテナからマウントされたボリュームとして、そのマウントポイントを扱います。 指定する値は JSON 配列として VOLUME ["/var/log/"] のようにするか、あるいは単純な文字列を複数与えます。 たとえば VOLUME /var/log や VOLUME /var/log /var/db などです。
```

2021-02-14 20:54:49
USER
```
USER <user>[:<group>]

または

USER <UID>[:<GID>]

USER 命令は、ユーザ名（または UID）と、オプションとしてユーザグループ（または GID）を指定します。 そしてイメージが実行されるとき、Dockerfile 内の後続の RUN、CMD、ENTRYPOINT の各命令においてこの情報を利用します。
```

2021-02-14 20:55:05
WORKDIR
```
WORKDIR /path/to/workdir

WORKDIR 命令はワークディレクトリを設定します。 Dockerfile 内にてその後に続く RUN、CMD、ENTRYPOINT、COPY、ADD の各命令において利用することができます。 WORKDIR が存在しないときは生成されます。 これはたとえ、この後にワークディレクトリが利用されていなくても生成されます。

WORKDIR 命令は Dockerfile 内にて複数利用することができます。 ディレクトリ指定に相対パスが用いられた場合、そのパスは、直前の WORKDIR 命令からの相対パスとなります。 たとえば以下のとおりです。

WORKDIR /a
WORKDIR b
WORKDIR c
RUN pwd

上の Dockerfile の最後の pwd コマンドは /a/b/c という出力結果を返します。
```

2021-02-14 20:55:39
ARG
```

ARG 命令は変数を定義して、ビルド時にその値を受け渡します。 これは docker build コマンドにおいて --build-arg <varname>=<value> フラグを利用して行います。 指定したビルド引数（build argument）が Dockerfile 内において定義されていない場合は、ビルド処理時に警告メッセージが出力されます。
```
