
2021-01-29 07:48:07
リファクタリングの本を読みながら、
サンプルコードを写経します。

2021-01-29 08:33:24
```
コンパイラはコードが汚いものであろうが、きれいに書かれていようが一向に気にしません。しかし変更となると、そこには人間が関わる必要が出てきます。

人間はまず間違いなく、コードのきれいさを気にします。設計のまずいシステムは変更が難しくなります。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.4). Kindle 版. 
```

継続的に変更を試みる状況下を想定するならリファクタリングは重要な要素だと思いました。

2021-01-29 08:54:41
```
リファクタリングを行うとき、最初にすることは常に同じです。
対象となるコードについてきちんとしたテスト群を作り上げることです。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.5). Kindle 版. 
```

2021-01-29 09:26:48
```
この変更はパフォーマンスに大きな影響を与えないし、たとえそうであってもコードが整然としていれば後からチューニングが容易にできるということです。 

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.14). Kindle 版. 
```

2021-01-29 09:38:01
```
一時変数は問題のもとです。
ルーチン内でのみ有効なため、長く複雑なルーチンができてしまいがちです。 
そこで次のリファクタリングとして、一時変数をいくつか置き換えます。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.16). Kindle 版. 
```

2021-01-29 12:15:19
コミットメッセージにやっていたことの大まかな説明が付けれていたらよかったなと思いました。

この章ででた固有のフレーズについて英語ではなんと表現するのか後で調べてみたいです。

2021-01-29 12:23:58
```
リファクタリングによって、パフォーマンスに重大な影響を及ぼしてしまうこともときにはあります。 たとえそうなったとしても、 私はかまわず作業を継続します。なぜならよく整理されたコードのほうが、後からパフォーマンスの最適化がしやすいからです。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.20). Kindle 版. 
```

2021-01-29 12:53:55
いったん読み進めるのを止めて各用語の英語を調べてみます。

- 関数の抽出
- 変数のインライン化
- 関数宣言の変更
- ループの分離
- ステートメントのスライド
- 問い合わせによる一時変数の置き換え

2021-01-30 11:31:10
- 関数の抽出
    Extract Method(Function)

- 変数のインライン化
    Inline Temp

- 関数宣言の変更
    Rename Method

- ループの分離
    Split Loop

- ステートメントのスライド
    Slide Statements

- 問い合わせによる一時変数の置き換え
    Replace Parameter with Query

Refactoring Techniques https://refactoring.guru/refactoring/techniques

Refactoring https://refactoring.com/

2021-01-30 14:52:12
Refactoring2の勉強を再開します

2021-01-30 14:53:26
```
込み入っている箇所を小さな単位に分割していくことは、名前付けと同じくらい重要なのです。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.24). Kindle 版. 
```

2021-01-30 15:01:10
- フェーズの分離
    Split Phase

2021-01-30 16:27:28
```
コード量は増えましたが、ロジックは認識しやすい形で、請求の計算処理部分と請求書のフォーマット作成部分とに分離されています。こうしたモジュール化により、コードの各部分の処理と、それらがどのように連携しているかを把握しやすくなります。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.33). Kindle 版. 
```

2021-02-01 14:54:24
Refactoring2 MFの続きをします。
Go言語に挑戦することにしたので、Refactoring2は区切りのいいところで中断します。

2021-02-01 17:00:10
- ポリモーフィズムによる条件記述の置き換え
- 関数の移動
- サブクラスによるタイプコードの置き換え
- ファクトリ関数によるコンストラクタの置き換え

2021-02-01 18:18:18
- ポリモーフィズムによる条件記述の置き換え
    Replace Conditional with Polymorphism

- 関数の移動
    Move Function

- サブクラスによるタイプコードの置き換え
    Replace Type Code with Subclasses

- ファクトリ関数によるコンストラクタの置き換え
    Replace Constructor with Factory Function

2021-03-06 23:16:46
Refactoring2を続きから読みます。

2021-03-06 23:34:44
```
そ  のため多くの人は、 機能ブランチを 2、 3 日程度の短いものに保つようにと主張します。 中には  私のようにもっと短い期間が望ましいとする人もいます。 このやり方が継続的インテグレーショ  ン （CI） で、 トランクベース開発とも呼ばれるものです。 CI では、 チームの各メンバは少なくと  も 1 日に 1回はメインブランチとの統合を行います。 これによってブランチが互いに離れすぎて  しまうのを防ぎ、 マージの複雑さを大幅に軽減します。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.59). Kindle 版. 
```

2021-03-06 23:40:18
```
つまり、 リファクタリングをしたいなら、 ほとんどの場合、自己テストコード [mf-stc] が必要と  いうことになります。 

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.60). Kindle 版. 
```

2021-03-06 23:55:38
```
通常のリファクタリングとの違いは、 データベースの変更は、 正式に至るまでに複数のリリー  スに分割するのがベストということです。 こうすることで、 本番運用で問題が起きても変更を取  り消すことが容易になります。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.62). Kindle 版. 
```

2021-03-07 00:02:58
```
複雑さを増幅させないような仕組  み （小さな、 わかりやすい名前の関数など） は積極的に採用しますが、 ソフトウェアを複雑にす  るような柔軟性の仕組みについては、 採用の前に有効性を証明しなければなりません。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.64). Kindle 版. 
```

この文脈では、
将来的に起こると予想される問題の解として柔軟性をもたせることは良くないのでしょうか。

2021-03-07 00:05:35
```
将来の変更に対して、 後でリファクタリングするのは難しいか  どうか、 見積もってみるとよいでしょう。 後でリファクタリングするほうが難しいと感じられる  ときには、 そこで初めて柔軟性の仕組みの導入を考えます。 

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.64). Kindle 版. 
```

なるほど

2021-03-14 07:32:40
リファクタリング2の読書の続きを読みます。

2021-03-14 07:32:58
```
プログラムを解析してみると、 ほとんどの時間がごく一部の  処理で集中的に消費されているという事実です。 そのため、 コード全体にわたって均等に最適  化を行ったとしても、 その活動の 90％ は無駄になるのです。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.67). Kindle 版. 
```

2021-03-17 08:36:11
Refactoring2を続きから読みます。

4章 テストの構築

2021-03-17 08:39:28
テストスイート
```
「何をテストするのか」という質問に答えるのが、テスト・ケース です。 テスト・ケースは、システムが正常に作動し、高レベルの品質で構築されていることを確認するために検証する必要のある要素を定義する目的で開発します。 テスト・スイートは、テスト実行の目的でグループ化された テスト・ケースのコレクションです。
```
テスト・ケースおよびテスト・スイートの概要 https://www.ibm.com/support/knowledgecenter/ja/SSYMRC_6.0.0/com.ibm.rational.test.qm.doc/topics/c_testcase_overview.html?origURL=SSJJ9R_6.0.0/com.ibm.rational.test.qm.doc/topics/c_testcase_overview.html

2021-03-17 08:41:39
自己テストコード
```
 機能的なソフトウェアと一緒に、結合テストにおける包括的な自動テストを書くプラクティスのことを指します。
```
自己テストコード https://bliki-ja.github.io/SelfTestingCode/

具体的にどんなテストを書いたらいいかはまだイメージができません。

2021-03-17 08:57:22
テストのためのサンプルコード

2021-03-17 09:45:50
最初のテスト

Mocha
Mocha - the fun, simple, flexible JavaScript test framework https://mochajs.org/
テストフレームワークを使った例があったので写経してみます。

2021-03-17 10:16:21
Mochaを動かせるようになりましたが、testコードの中でテスト対象のクラスのファイルが見つけられなかったっぽいです。

2021-03-17 10:38:15
```
var Province = require('../province.js');
```
を追加するとProvinceはコンストラクタではないとエラーが出ました。

2021-03-17 10:53:26
javascript - Getting Unexpected Token Export - Stack Overflow https://stackoverflow.com/questions/38296667/getting-unexpected-token-export

この情報がヒントになりました。

```
module.exports = class Province {}
```

2021-03-17 11:01:13
うまくいきました。

2021-03-17 11:08:19
Chai アサーションライブラリ

Chai https://www.chaijs.com/
Assertion Styles - Chai https://www.chaijs.com/guide/styles/#assert

2021-03-17 11:17:22
テストの追加

フィクスチャ
```
テストを実行、成功させるために必要な状態や前提条件の集合を、フィクスチャと呼ぶ。これらはテストコンテキストとも呼ばれる。開発者はテストの実行前にテストに適した状態を整え、テスト実行後に元の状態を復元することが望ましい。
```
テストフィクスチャとは何？ Weblio辞書 https://www.weblio.jp/content/%E3%83%86%E3%82%B9%E3%83%88%E3%83%95%E3%82%A3%E3%82%AF%E3%82%B9%E3%83%81%E3%83%A3

2021-03-22 17:01:22
Refactoring2 6章を読みます

リファクタリングはじめの一歩

2021-03-22 17:04:27
```
最も広く使われるリファクタリングは、 コードから関数を抽出すること （「関数の抽出  （p.112）」） と、 変数を抽出すること （「変数の抽出（p.125）」） です。 リファクタリングは変更に関  するすべてを扱います。 したがってこれらの逆リファクタリング（「関数のインライン化（p.121）」  や「変数のインライン化（p.129）」） も当然よく使います。 

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.111). Kindle 版. 
```

抽出とインライン化について勉強したいと思います。

2021-03-22 22:30:07
関数の抽出

Extract Function https://refactoring.com/catalog/extractFunction.html

2021-03-23 15:58:10
Refactoring2 ６章の続きから読みます。

2021-03-23 15:59:26
関数のインライン化
Inline Function https://refactoring.com/catalog/inlineFunction.html

2021-03-23 16:22:03
変数の抽出
Extract Variable https://refactoring.com/catalog/extractVariable.html

```
「変数の抽出」を検討するのは、 コード内の式に名前を付けたいときです。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.125). Kindle 版. 
```

2021-03-23 16:51:14
変数のインライン化
Inline Variable https://refactoring.com/catalog/inlineVariable.html

```
ときに  は名前が式以上のことを語らないこともあります。 また、 変数が周辺コードのリファクタリング  の邪魔になっていることもあるでしょう。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.129). Kindle 版. 
```

2021-03-23 16:59:56
関数宣言の変更
Change Function Declaration https://refactoring.com/catalog/changeFunctionDeclaration.html

```
関数宣言はソフトウェアシ  ステムにおける継ぎ目となります。 あらゆる建造物と同様、多くの部分がこうした継ぎ目に依存  しています。 良い継ぎ目があればシステムに新たな部品を追加するのは簡単です。 悪い継ぎ目は  常に問題の発生源になります。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.130). Kindle 版. 

（名前を改善していくための良い方法は、 関数の目的をコメントとして  書くことです。 そのコメントを名前に変えます）。 

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.131). Kindle 版. 

関数のパラメータは、 関数内部と外界がどのよう  に関わりあうかを規定します。 パラメータは関数を使う場合の文脈を設定します。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.131). Kindle 版. 

モジュールが互  いに知らなければならないことを減らせば、 自分が何かを変更するときに頭に入れておかなけれ  ばならないことが削減できます。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.131). Kindle 版. 


大切なのは、 「関数宣言の変更」に慣れ親しんでおき、 最善のコードの継ぎ目がわかる  につれてコードを進化させられるようにしておくことなのです。 

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.131). Kindle 版. 

この簡易な手順によるリファクタリングの欠点は、 すべての呼び出し箇所とその宣言 （ポリ  モーフィックな場合はすべての宣言） を一度に変更しなければならないことです。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.133). Kindle 版. 
```

2021-03-25 00:48:53
指示通りにやると何故かうまくできました。
いろんなシチュエーションで関数宣言の変更を練習しないと慣れない気がします。
このやり方の便利さはわかりましたが、どうしてうまくいったのかまだわかっていません。

2021-03-25 00:53:32
Refactoring2の続きから読みます。

６章

2021-03-25 00:53:59
変数のカプセル化
Encapsulate Variable https://refactoring.com/catalog/encapsulateVariable.html

```
関数を使うということは、 通常は関数を呼び出すということです。  そのため、 古い関数を転送用関数として残すことで、 関数に新たな名前を付けたり移動したりす  ることが簡単にできます （古い呼び出しは古い関数を呼び出すままにしておき、 古い関数が新た  な名前の元の関数を呼びます）。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.138). Kindle 版. 

データはこうした対処ができないのでより厄介です。 データを移動してもコードが動き続ける  ためには、 データのすべての参照を一気に変更する必要があります。 小さな関数内の一時変数  のように、 非常にスコープの狭いデータであればこれは問題になりません。 しかしスコープが大  きくなるにつれ困難になっていきます。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.138). Kindle 版. 

そのため広い範囲で利用されるデータを移動したいときは、 まずそれをカプセル化して、 変数  へのアクセスを関数経由にするのが非常に良いやり方です。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.138). Kindle 版. 

データの変更や参照を監視できると  いう明確な利点が得られます。 データ更新の際の検証や後処理を追加するのも簡単です。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.138). Kindle 版. 

そのスコープが一つの関数よ  り大きいものは、 関数を通じてのみアクセスできるようにします。 データのスコープが大きくな  るほどカプセル化はより重要になります。 

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.138). Kindle 版. 

パブリックなフィールドを見かけたときは 「変数のカプセ  ル化」（この場合は 「フィールドのカプセル化（p.138）」 とよく呼ばれます） を施して、 変数の可視  性を下げることを考えます。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.139). Kindle 版. 
```

2021-03-25 01:27:47
- 値のカプセル化
```
ときにはより深くカプセル化を行い、 変数の  みならずその内容まで制御したくなることもあります。  それにはいくつかの選択肢があります。 最も簡単なのは値へのあらゆる変更を禁ずることで  す。 お気に入りの方法は、 getter をデータのコピーを返すように修正することです。 

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.141). Kindle 版. 
```

2021-03-25 01:29:58
```
export function getDefaultOwner() {
    return Object.assign({}, defaultOwnerData);
}
```
javascriptをよく知らずに書いてますが、値だけを返したりするのはjavascriptは苦手なのでしょうか。
静的型付け言語なら値だけ返す状況はシンプルにかけるのでここは違うところなのかもしれません。

2021-03-26 01:33:15
```
厳密に何をどのようにカプセル化すべきかは、 データの利用法と想定される変更とに  よって変わってきます。 データが広く使われるほど、 適切にカプセル化することについて注意を  払う価値があります。 

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.142). Kindle 版. 
```

2021-03-26 20:45:26
Refactoring2 6章の続きから読みます。

2021-03-26 20:46:00
変数名の変更
Rename Variable https://refactoring.com/catalog/renameVariable.html

```
変数が広く使われている場合、「変数のカプセル化（p.138）」 を検討する。 

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.143). Kindle 版. 
```
変数をリネームするときは変数をカプセル化するいい機会ということなんだと思います。

2021-03-26 21:07:48
パラメータオブジェクトの導入
Introduce Parameter Object https://refactoring.com/catalog/introduceParameterObject.html

```
データを構造体にまとめることには意味があります。 データ項目間の関係を明示することがで  きるからです。 新たな構造体を使えば、 関数のパラメータ数は少なくて済みます。 その構造体を  使うすべての関数が、 構造体の要素を取得するのに同じ名前を使うことで、 一貫性の向上にも  役立ちます。 

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.146). Kindle 版. 
```

2021-03-26 21:11:33
```
新たな構造体を特定したら、 その構造体を使うようにプログラムの振る舞いを改めます。 そして、  このデータに関する共通の振る舞いをとらえた関数群を作ります。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.146). Kindle 版. 

そうした構造体を新たな抽象に引き上げ  ると、 問題領域の理解がすっきりしてきます。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.146). Kindle 版. 
```

2021-03-26 21:35:55
```
このようなクラスを作ること  の大きな利点は、 新たなクラスに振る舞いを移すことができるということです。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.149). Kindle 版. 
```

2021-04-04 15:38:37
Refactoring2の続きから読みます。

2021-04-04 16:09:32
関数群のクラスへの集約

Combine Functions into Class https://refactoring.com/catalog/combineFunctionsIntoClass.html

2021-04-05 17:22:02
関数群の変換への集約

Combine Functions into Transform https://refactoring.com/catalog/combineFunctionsIntoTransform.html

```
関数群を集約したい理由として、 派生値を求めるロジックの重複を避けたいということがあり  ます。 それだけなら、 単に 「関数の抽出 （p.112）」 をロジックに適用する手もありますが、 関数  が扱うデータ構造と近い位置に置かれていないと、 関数を見つけ出すのが難しくなります。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.155). Kindle 版. 
```

2021-04-08 17:29:40
フェーズの分離
Split Phase https://refactoring.com/catalog/splitPhase.html

```
分離に力を割くのは、 変更が必要になったときに、 トピックごとに分  けて対処することができ、 両方を一度に頭に入れる必要がないからです。 運が良ければ片方の  モジュールだけを変更すれば済みます。 もう一方のモジュールの詳細を思い出す必要はありませ  ん  。 

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.160). Kindle 版. 

確実な手がかりは、 処理の段階によって  使用するデータのセットや関数が決まっている場合です。 それらを別々のモジュールに分けるこ  とで、 コード上に違いを明示できます。 

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.161). Kindle 版. 
```

2021-04-08 18:03:06
OFF TOPIC
Vimの選択範囲置換 - Qiita https://qiita.com/mikene_koko/items/90522bce9473803c2d83

vimのハイライトを消す - Qiita https://qiita.com/A-gen/items/5f7fcfed36ece5eab3d1

2021-04-08 18:18:37
７章 カプセル化

```
モジュールとして分割すべきかを決める基準としておそらく最も重要なことは、 システムの  他の部分から隠蔽すべき秘密を持っているかということです [Parnas]。 データ構造は最も典型  的な秘密です。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.167). Kindle 版. 
```

2021-04-08 18:24:14
レコードのカプセル化
Encapsulate Record https://www.refactoring.com/catalog/encapsulateRecord.html

```
レコード構造は、 プログラミング言語の一般的な機能です。 それらは関連するデータを一緒に  グループ化する直感的な方法を提供し、 緩いデータの群れの代わりに意味のあるデータ単位を  渡すことを可能にします。 しかし、 単純なレコード構造には欠点があります。 最も厄介なのは、  レコードに格納されている値と計算した値の明確な区別を強要されることです。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.168). Kindle 版. 
```

```
レコードの構造には 2種類あります。 正規にフィールド名を宣言したものと、 任意の名前を使  えるものです。 後者はハッシュ、 マップ、 ハッシュマップ、 辞書、連想配列などと呼ばれ、 クラ  スライブラリで提供されます。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.169). Kindle 版. 

欠点はどのようなフィールドを保持す  るかが明示されないことです。 フィールドとして start と end があるのか、 start と length  があるのかは、 ハッシュマップの生成箇所や利用箇所を見るしかありません。 プログラムの小さ  な範囲でのみ使われているなら問題ありませんが、 使用範囲が広いと暗黙の構造がもたらす問題  はますます大きくなります。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.169). Kindle 版. 
```

2021-04-08 19:30:40
後でやりたいこと
- プロキシの実装
```
読み取り専用のデータ構造プロキシを返すことです。 プロキシは背後のオ  ブジェクトをクライアントのコードが変更しようとすると例外を上げます。 言語によっては容易  に実現できますが、 JavaScript では大変です。 皆さんへの練習問題としておきます。 あるいは、  コピーを作った場合も、 更新を検出するために、 再帰的に凍結することも考えられます。 

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.174). Kindle 版. 
```

2021-04-08 19:41:37
```
getter と新たなクラスを巧妙に組み合わせることで事足りる場合もあります。 これは、  getter で構造を掘り進み、 カプセル化されていないデータの代わりにデータ構造をラップした  オブジェクトを返すという方法です。 これについては “Refactoring Code to Load a Document”  [mf-ref-doc] （ドキュメント読み込みコードのリファクタリング） という記事で説明しています。 

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.175). Kindle 版. 
```

2021-04-08 19:42:45
レコードのカプセル化
を読み終わりました。

2021-04-15 17:53:40
Refactoring 2の続きから読みます。

2021-04-15 18:37:25
コレクションのカプセル化

Encapsulate Collection https://refactoring.com/catalog/encapsulateCollection.html

```
カプセル化は特にオブジェクト指向の開発者が奨励するもので  すが、 コレクションの扱いについてはよくある誤りがあります。 コレクションの変数へのアクセ  スはカプセル化されていても、 getter でコレクションそのものを返してしまうと、 コレクション  を保持するクラスを介さずに、 その中身を変更できてしまうことです。 

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.176). Kindle 版. 

重要なのはコードベースにおける一貫性です。 どちらか一方だけを使いましょう。 そうすれば、  全員がその振る舞いに慣れ、 コレクションのアクセサを呼ぶときに、 その動きを期待するように  なるからです。 

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.177). Kindle 版. 
```

2021-04-25 01:06:32
Refactoring2の本を続きから読みます。

この本が読み終わったらしたいこと
- 過去の自分が書いたコードを練習台にリファクタリング

2021-04-25 01:10:05
オブジェクトによるプリミティブの置き換え

Replace Primitive with Object https://refactoring.com/catalog/replacePrimitiveWithObject.html

2021-04-25 01:17:11
```
開発の初期段階では、 情報を見たままの数値や文字列といったデータ項目で表現してしまい  がちです。 ところが開発が進むにつれ、 単純な項目 と思っていたものがそれほど単純ではなく  なってきます。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.181). Kindle 版. 

単純な表示以上のことをする必要があるとわかったならすぐに、 ちょっとしたデータでも新た  なクラスにしてしまいましょう。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.181). Kindle 版. 
```
表示以上のことをするリテラル値をクラスにラップすると、後で値の変更をするときやその値を使った処理を考える際の心理的な負担を減らせることを実感できました。

2021-04-25 02:06:50
instanceof 演算子とは

instanceof - JavaScript | MDN https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/instanceof

2021-04-25 02:24:14
問い合わせによる一時変数の置き換え

Replace Temp with Query https://refactoring.com/catalog/replaceTempWithQuery.html

2021-04-25 02:26:19
```
一時変数の用途の一つは、 あるコードの値を保持しておき、 関数の後ろのほうでそれを参照で  きるようにすることです。 一時変数を使うことで、 値の参照はもちろん、 その意味を説明し、 値  を計算するためのコードが繰り返されるのを防ぐことができます。 確かにこうした変数は便利な  のですが、 もう一歩進めて関数にするとさらに有意義なこともあります。 

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.185). Kindle 版. 

このリファクタリングはクラスの中で使うのが最も効果的です。 クラスは、 抽出しようとして  いるメソッド間で共通となるコンテキストを与えてくれるからです。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.185). Kindle 版. 

「問い合わせによる一時変数の置き換え」 に適した一時変数はほんの一部です。 あらかじめ計  算された結果を後から参照するためだけの変数に限られます。 一度しか代入されない変数が、  最も単純な例です。 しかし、 複雑なコードから複数回代入される変数でも、 当てはまることが  あります。 その複雑なコードをクエリに抽出できる場合がそうです。 さらに、 変数を計算するロ  ジックは、 変数が後で使われたときも同じ結果値を返す必要があります。

ＭａｒｔｉｎＦｏｗｌｅｒ. リファクタリング 既存のコードを安全に改善する（第2版） (p.186). Kindle 版. 
```

クラス内の一時変数を関数に置き換えることで、ロジックが見えやすくなることが実感できました。
置き換えた関数はもとの一時変数だったころよりスコープが広くなりますが、返ってくる値が常に同じものになる一時変数しか置き換えないので、クラス内のスコープであれば問題ないように感じました。

2021-04-25 02:57:53
クラスの抽出
Extract Class https://www.refactoring.com/catalog/extractClass.html

2021-04-25 03:38:04
例ではPersonクラスから電話番号の情報を切り離しました。

切り離したことで、フィールドの名前がシンプルなものになってわかりやすくなった気がします。

クラスから情報を切り離したあとで、その情報が汎用的に使えることに気付けるかもしれません。

2021-04-25 03:43:00
クラスのインライン化
Inline Class https://refactoring.com/catalog/inlineClass.html

リファクタリングの過程で責務が殆どないクラスがうまれることがあるそうです。

また、一旦要素をまとめてから抽出のリファクタリングで要素を分離するということをしたいときに、要素をまとめるときにインライン化が使えるそうです。

2021-04-25 04:17:06
委譲の隠蔽
Hide Delegate https://www.refactoring.com/catalog/hideDelegate.html

2021-04-25 04:20:31
クライアントコードと委譲先のオブジェクトの中間にサーバオブジェクトがある

```
class server {
}
class client {
    // 委譲先のオブジェクトを知っていないといけない
}
```

2021-04-25 04:27:05
移譲についてよくわかっていない気がしてきました。
調べてみます。

プログラマーを惑わせる３種類の委譲(委譲・Delegation／転送・Forwarding／.NET Delegates) - Qiita https://qiita.com/jesus_isao/items/4b6b7846ccf5eb46b1bc

```
「委譲」や「デリゲート」が指すものはプログラマーによって違うことがある。
少なくとも下記３パターンあってマジ初見殺しだよねって話です。

    Forwarding（転送）のこと。GoFがDelegationであると誤用して広まった。元は誤用なのにこれが多数派。
    JavaScriptなどのプロトタイプベースオブジェクト指向言語などでよく出てくる真のDelegationのこと。Henry Liebermanが定義した。（※JSの場合は暗黙の委譲をよく使っているはず）
    .NET Frameworkの仕様であるDelegatesや、その実装のこと。

```

文脈によって意味が変わってくるっぽいです。

2021-04-25 04:46:51
```
有名なFowlerの『リファクタリング』でも、結城浩の『Java言語で学ぶデザインパターン入門』でも、ついでに2018年10月26日現在の日本語Wikipediaの「委譲」のページでも、転送が委譲として紹介されています。
```
委譲その１の可能性が高くなってきました。

2021-04-25 04:56:12
転送（Forwarding）
```
クラスベースオブジェクト指向プログラミング言語では、継承という機能が存在します。
転送は、この継承と対になるように登場することがあります。継承と、転送。「この場合は継承より転送の方がいいね」みたいに言います。（※実際には転送ではなく、「委譲」と書かれることがほとんどです。）
```

```
上で私が書いた例でいうと、人間（ForwardingHuman）クラスは哺乳類（Mammal）クラスをラップした（＝包み込んだ）、ラッパーオブジェクトなわけですね。ForwardingHumanクラスのメンバであるIntroduceMyself()メソッドがMammalクラスのIntroduceMyself()メソッドに転送しているということです。
ちなみにラップする側のラッパー（wrapper）に対して、ラップされる側をラッピー（wrappee）ということもあります。ラッパーはラッピーに転送します。
```

```
じゃあなんで継承で書かないの？　と思うかもしれません。もちろん理由はあります。継承で書けるなら、継承で書いても良いのです。しかし継承ではどうにもならないケースというのも確かに存在します。たとえば、継承では、子クラスから見た親クラスは常に固定化されています。親クラス１に対して、子クラスがnある関係です。子クラスが１で、親クラスがnにはなれません。継承している子クラスは、別の親クラスに継承先を切り替えることができません。そのため、次で紹介するような転送を使ったデザインパターンが登場します。
```

なるほど。親をn個にできるんですね。

```
人種と性格の組み合わせは4*4=16通りです。コーカソイド神経質、コーカソイド外交的、コーカソイド調和的、コーカソイド勤勉……オーストラロイド勤勉まで、全部で16通りの組み合わせを作る必要があります。

もし、Strategyパターンを知らないというのであれば、Strategyについて学び、モンゴロイドで外交的な人間などをぜひ実装してみて下さい。
おそらく2つのinterfaceと4つの人種クラス、4つの性格クラス、そしてそれらに転送をする人間クラスができるはずです。
```

Strategyパターンは過去に写経したことがありますが、忘れました。

調べてみます。

2021-04-25 06:26:42
:)
サンプルの問題がとけました。

満足感が出てきたので、今日はここまでにしようと思います。

プログラマーを惑わせる３種類の委譲(委譲・Delegation／転送・Forwarding／.NET Delegates) - Qiita https://qiita.com/jesus_isao/items/4b6b7846ccf5eb46b1bc

（２）Henry Liebermanが定義した、真の委譲（Delegation）

次回は上記の章から再開してRefactoring2に戻りたいです。

2021-04-29 10:00:25
Refactoring2の続きを読みます。

```
2021-04-25 04:17:06
委譲の隠蔽
Hide Delegate https://www.refactoring.com/catalog/hideDelegate.html
```

この続きから読みます。

2021-04-29 10:02:45
こういう感じのイメージでしょうか

class Server {
    private IFoo _foo;

    public void Server(IFoo foo) {
        _foo = foo
    }

    public void Do() {
        _foo.Do();
    }
}

interface IFoo {
    public void Do();
}

よくわからないので読み進めます。
